/*
  Mini-Chess for Sprig – FULLY PLAYABLE
  8×8 board, two-player hot-seat, legal moves only.
  w a s d  : move cursor
  i        : pick up / drop piece
*/

const C_WHITE = "w";
const C_BLACK = "b";

const PAWN   = "p";
const ROOK   = "r";
const KNIGHT = "n";
const BISHOP = "b";
const QUEEN  = "q";
const KING   = "k";

const COL_WHITE = 7;
const COL_BLACK = 0;

let board = [];
let turn  = C_WHITE;
let selected = null;   // {x,y}
let legalSquares = []; // [{x,y}, …] to highlight

/* ---------- board init ---------- */
function initBoard() {
  board = Array.from({length: 8}, () => Array(8).fill(null));
  const backRank = [ROOK, KNIGHT, BISHOP, QUEEN, KING, BISHOP, KNIGHT, ROOK];
  for (let x = 0; x < 8; x++) {
    board[1][x] = {color: C_BLACK, type: PAWN};
    board[6][x] = {color: C_WHITE, type: PAWN};
    board[0][x] = {color: C_BLACK, type: backRank[x]};
    board[7][x] = {color: C_WHITE, type: backRank[x]};
  }
}

/* ---------- movement logic ---------- */
function inBounds(x, y) { return x >= 0 && x < 8 && y >= 0 && y < 8; }
function isEnemy(p, c) { return p && p.color !== c; }
function isFriend(p, c) { return p && p.color === c; }

function rawMoves(x, y) {
  const p = board[y][x];
  if (!p) return [];
  const {color, type} = p;
  const moves = [];
  const pushSlide = (dx, dy) => {
    let nx = x + dx, ny = y + dy;
    while (inBounds(nx, ny)) {
      const t = board[ny][nx];
      if (!t) moves.push({x: nx, y: ny});
      else { if (isEnemy(t, color)) moves.push({x: nx, y: ny}); break; }
      nx += dx; ny += dy;
    }
  };
  const pushStep = (dx, dy) => {
    const nx = x + dx, ny = y + dy;
    if (inBounds(nx, ny) && !isFriend(board[ny][nx], color))
      moves.push({x: nx, y: ny});
  };

  switch (type) {
    case PAWN: {
      const dir = color === C_WHITE ? -1 : 1;
      const start = color === C_WHITE ? 6 : 1;
      if (inBounds(x, y + dir) && !board[y + dir][x])
        moves.push({x, y: y + dir});
      if (y === start && !board[y + 2 * dir][x])
        moves.push({x, y: y + 2 * dir});
      [-1, 1].forEach(dx => {
        const nx = x + dx, ny = y + dir;
        if (inBounds(nx, ny) && isEnemy(board[ny][nx], color))
          moves.push({x: nx, y: ny});
      });
      break;
    }
    case KNIGHT:
      [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]].forEach(([dx,dy]) => pushStep(dx, dy));
      break;
    case KING:
      [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([dx,dy]) => pushStep(dx, dy));
      break;
    case ROOK:   [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy]) => pushSlide(dx, dy)); break;
    case BISHOP: [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dx,dy]) => pushSlide(dx, dy)); break;
    case QUEEN:  [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dx,dy]) => pushSlide(dx, dy)); break;
  }
  return moves;
}

function findKing(color) {
  for (let y = 0; y < 8; y++)
    for (let x = 0; x < 8; x++) {
      const p = board[y][x];
      if (p && p.type === KING && p.color === color) return {x, y};
    }
  return null;
}

function inCheck(color) {
  const k = findKing(color);
  if (!k) return false;
  for (let y = 0; y < 8; y++)
    for (let x = 0; x < 8; x++) {
      const p = board[y][x];
      if (p && p.color !== color && rawMoves(x, y).some(m => m.x === k.x && m.y === k.y)) return true;
    }
  return false;
}

function legalMoves(x, y) {
  const p = board[y][x];
  if (!p) return [];
  return rawMoves(x, y).filter(m => {
    const target = board[m.y][m.x];
    board[m.y][m.x] = p;  board[y][x] = null;
    const ok = !inCheck(p.color);
    board[y][x] = p;  board[m.y][m.x] = target;
    return ok;
  });
}

/* ---------- graphics ---------- */
const wPawn = bitmap`
....1111........
...11111........
..1111111.......
..1111111.......
....1111........
....1111........
...11111........
................
................
..1111111.......
..1111111.......
.11111111.......
.11111111.......
.11111111.......
.11111111.......
.11111111.......`;

const bPawn = bitmap`
....0000....
...00000....
..0000000...
..0000000...
....0000....
....0000....
...00000....
............
............
..1111111...
..1111111...
.11111111...
.11111111...
.11111111...
.11111111...
.11111111...`;

const wRook = bitmap`
111111111111....
111111111111....
111111111111....
111111111111....
111111111111....
111111111111....
111111111111....
111111111111....
111111111111....
111111111111....
111111111111....
111111111111....
111111111111....
111111111111....
111111111111....
111111111111....`;

const bRook = bitmap`
000000000000....
000000000000....
000000000000....
000000000000....
000000000000....
000000000000....
000000000000....
000000000000....
000000000000....
000000000000....
000000000000....
000000000000....
000000000000....
000000000000....
000000000000....
000000000000....`;

const wKnight = bitmap`
....111.........
...11111........
..1111111.......
..111..11.......
..11....1.......
..1.....1.......
................
................
..1111111.......
..11...11.......
..11...11.......
.111...111......
.1111.1111......
.1111.1111......
.111111111......
..111.111.......`;

const bKnight = bitmap`
....000.....
...00000....
..0000000...
..000..00...
..00....0...
..0.....0...
............
............
..1111111...
..11...11...
..11...11...
.111...111..
.1111.1111..
.1111.1111..
.111111111..
..111.111...`;

const wBishop = bitmap`
....111.........
...11111........
..1111111.......
..1111111.......
...11111........
....111.........
...11111........
..1111111.......
................
..1111111.......
..1111111.......
.11111111.......
.111.1111.......
.111.1111.......
.11111111.......
.11111111.......`;

const bBishop = bitmap`
....000.....
...00000....
..0000000...
..0000000...
...00000....
....000.....
...00000....
..0000000...
............
..1111111...
..1111111...
.11111111...
.111.1111...
.111.1111...
.11111111...
.11111111...`;

const wQueen = bitmap`
....111.........
...11111........
..1111111.......
..1111111.......
..1111111.......
...11111........
....111.........
...11111........
..1111111.......
................
.111111111......
.111111111......
.111.1.111......
.111.1.111......
.111111111......
.111.1.111......`;

const bQueen = bitmap`
....000.....
...00000....
..0000000...
..0000000...
..0000000...
...00000....
....000.....
...00000....
..0000000...
............
.111111111..
.111111111..
.111.1.111..
.111.1.111..
.111111111..
.111.1.111..`;

const wKing = bitmap`
....111.........
...11111........
..1111111.......
..1111111.......
..1111111.......
...11111........
....111.........
...11111........
..1111111.......
................
.111111111......
.111.1.111......
.111.1.111......
.111.1.111......
.111111111......
.111111111......`;

const bKing = bitmap`
....000.....
...00000....
..0000000...
..0000000...
..0000000...
...00000....
....000.....
...00000....
..0000000...
............
.111111111..
.111.1.111..
.111.1.111..
.111.1.111..
.111111111..
.111111111..`;

setLegend(
  ["p", wPawn],
  ["r", wRook],
  ["n", wKnight],
  ["b", wBishop],
  ["q", wQueen],
  ["k", wKing],
  ["P", bPawn],
  ["R", bRook],
  ["N", bKnight],
  ["B", bBishop],
  ["Q", bQueen],
  ["K", bKing]
);

setMap(map`
........
........
........
........
........
........
........
........`);

/* ---------- drawing + highlighting ---------- */
function redraw() {
  clearText();
  // reset tile colours (chessboard pattern)
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const spr = getTile(x, y)[0];
      if (spr) spr.color = (x + y) % 2 === 0 ? 2 : 5;
    }
  }
  // pieces
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const p = board[y][x];
      let spr = ".";
      if (p) {
        const base = p.type === KING ? "K" : p.type;
        spr = p.color === C_WHITE ? base : base.toUpperCase();
      }
      addSprite(x, y, spr);
    }
  }
  // highlight selected square
  if (selected) {
    const spr = getTile(selected.x, selected.y)[0];
    if (spr) spr.color = 3;
  }
  // highlight legal moves
  legalSquares.forEach(m => {
    const spr = getTile(m.x, m.y)[0];
    if (spr) spr.color = 4;
  });
}

/* ---------- input ---------- */
onInput("w", () => { if (getY() > 0) { setCursor(getX(), getY() - 1); redraw(); } });
onInput("s", () => { if (getY() < 7) { setCursor(getX(), getY() + 1); redraw(); } });
onInput("a", () => { if (getX() > 0) { setCursor(getX() - 1, getY()); redraw(); } });
onInput("d", () => { if (getX() < 7) { setCursor(getX() + 1, getY()); redraw(); } });

onInput("i", () => {
  const cx = getX(), cy = getY();
  if (!inBounds(cx, cy)) return;
  const p = board[cy][cx];
  if (selected) {
    const moves = legalMoves(selected.x, selected.y);
    if (moves.some(m => m.x === cx && m.y === cy)) {
      board[cy][cx] = board[selected.y][selected.x];
      board[selected.y][selected.x] = null;
      if (board[cy][cx].type === PAWN && (cy === 0 || cy === 7))
        board[cy][cx].type = QUEEN;
      turn = turn === C_WHITE ? C_BLACK : C_WHITE;
    }
    selected = null; legalSquares = [];
  } else {
    if (p && p.color === turn) {
      selected = {x: cx, y: cy};
      legalSquares = legalMoves(cx, cy);
    } else {
      selected = null; legalSquares = [];
    }
  }
  redraw();
});

/* ---------- start ---------- */
initBoard();
redraw();